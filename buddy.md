# Memory Allocation (buddy.c)

## 题目描述

Buddy Memory Allocation 是一种内存管理算法。在本题中，我们需要实现这个算法的简化版本。

假设计算机在分配内存时总是分配大小为 $ 2^k\; (k \in \mathbb{N}) $ 的内存空间。例如，若某应用程序需要大小为 5 的内存空间，计算机则会分配大小为 $ 8 = 2^3$ 的一块内存。

为了便于管理，Buddy 将整个内存空间视作一个“空间链”，由多个“空间节点”连接组成，每个“空间节点”负责管理一个大小固定为 $ 2^i \quad (\text{for some } i \in \mathbb{N}) $ 的内存空间块。

每次分配内存时，会先寻找大小合适的“空间节点”；如果找不到，则会触发“空间分裂”操作。下面，我们通过例子演示 Buddy 算法的过程。

- 初始时，计算机内存为一块，在此例子中假设其大小为 $ 2^4 = 16$ 。初始时没有应用程序在运行，“空间链”如图，仅有一个“空间节点”（free 表示该空间尚未被分配给任何应用程序）。最右侧节点表示链表的结尾，为空指针。![p1.png](http://file.tilnel.com//uploads/2022-03-04-p1.png)
- 假设现有应用程序 A 申请大小为 $ 3$ 的内存空间，则计算机将会分配大小为 $ 4 = 2^2$ 的一块内存。首先，Buddy 寻找当前“空间链”中有没有**空闲的、大小恰好为 $ 4$** 的“空间节点”。本例中，没有找到。然后 Buddy 将会选择**大小严格超过 $ 4$ 的、最靠前**的“空间节点”，本例中为仅有的一个节点，将其分裂为大小相等的两个“空间节点”，连接后代替原节点放入“空间链”中，如图所示。![p2.png](http://file.tilnel.com//uploads/2022-03-03-p2.png)
- 分裂后，Buddy 重新尝试寻找当前是否有**空闲的、大小恰好为 $ 4$** 的“空间节点”，仍然没有，则 Buddy 此次寻找到**大小严格超过 $ 4$ 的、最靠前**的“空间节点”，本例中为第一个节点，将其分裂。![p3.png](http://file.tilnel.com//uploads/2022-03-03-p3.png)
- 此次分裂后，Buddy再次尝试寻找**空闲的、大小恰好为 $ 4$** 的“空间节点”，有两个节点符合要求，则 Buddy 选择**最靠前的**的节点，此为第一个节点，将其分配给 A 。![p4.png](http://file.tilnel.com//uploads/2022-03-03-p4.png)
- 假设此时又有应用程序 B 申请大小为 $ 2$ 的内存空间，计算机将会分配大小为 $ 2 = 2^1$ 的内存空间。重复以上过程，Buddy 首先寻找**空闲的、大小恰好为 $ 2$** 的“空间节点”。本例中，没有找到。Buddy 找到**大小严格超过 $ 2$ 的、最靠前**的“空间节点”，此为 A 所使用节点的下一个节点，将其分裂。![p5.png](http://file.tilnel.com//uploads/2022-03-03-p5.png)
- 分裂之后，Buddy 将第二个节点分配给 B。![p6.png](http://file.tilnel.com//uploads/2022-03-03-p6.png)
- 假设此时又有应用程序 C 申请大小为 6 的内存空间，则计算机将会分配大小为 $ 8 = 2^3$ 的内存空间。Buddy 在寻找的过程中发现了**空闲的、大小恰好为 $ 8$** 的“空间节点，将其直接分配给 C。![p7.png](http://file.tilnel.com//uploads/2022-03-03-p7.png)我们注意到，A、B 和 C 的中间，有一个“空间节点”是空闲的，Buddy 允许这种情况出现。

下面给出 Buddy 算法分配内存过程的较为形式化的描述，供参考：

- 初始时，计算机内存为一块，大小给定，此时的“空间链”仅包含一个“空间节点”。
- 分配内存时，假设需要的内存块大小为 $ 2^k $：

1. 寻找**现有的**大小**恰好**为 $ 2^k $ 的“空间节点”中是否有还未被分配的。
2. 若有，分配最靠前的那个。
3. 若没有，则寻找大小$> 2^k $ 的、最靠前的、未被分配的“空间节点”，将其分裂成大小分别为原来一半、位置相邻的两个新“空间节点”，按次序连接之后替换原“空间链”中被分裂的节点；重复过程 1。

在本题中，你需要支持两种操作：

- `A id m` 表示一个识别码为 $id$ 的程序请求大小为 $m$ 的内存空间。
- `Q` 表示查询系统中当前空间的分配情况。

## 输入格式

- 第一行输入两个正整数 $ n$ 和 $ q$，以空白符相隔，分别表示计算机的内存大小为 $ 2^ n$ 以及操作的总数。
- 接下来有 $ q$ 行，每行一个操作，格式如上所述。

## 输出格式

对于每一个 `Q` 询问，输出两行：

- 第一行为一个整数 $ m$ ，表示当前“空间链结点”的总数。
- 第二行依次输出 $m$ 个整数，按照起始地址从小到大输出每一个“空间结点”上的应用程序的 $ id$ ，若某节点空闲，则输出 `0` 。

## 脚注

- 对于 30% 的数据，保证计算机每次分配的内存空间都相同。
- 对于 100% 的数据，保证 $ n < 31,  q \leq 10000$，所有的 $ id$ 不超过 int 范围；保证每次操作合法，即：内存空间足够，应用程序的 $ id$ 互不相同。
- 请使用链表实现；若使用非链表的方式，经助教人工检查，最多只可获得 60% 的分数。

## 样例输入

4 7
Q
A 1 1
Q
A 2 1
Q
A 3 2
Q

## 样例输出

1
0
5
1 0 0 0 0
5
1 2 0 0 0
5
1 2 3 0 0
